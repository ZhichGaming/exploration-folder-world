<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/RGBELoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/pmrem/PMREMGenerator.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/geometries/RoundedBoxGeometry.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
      font-family: 'Space Grotesk', sans-serif;
    }

    .circle-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .circle {
      position: absolute;
      width: 0;
      height: 0;
      border-radius: 50%;
      background-color: white;
      animation: circleExpand 1s ease-out forwards;
    }

    .hidden-button {
      display: none;
      transform: scale(0);
    }

    .shown-button {
      display: block;
      animation: buttonExpand 1s ease-out;
    }

    .start-button {
      position: absolute;
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(2,0,36,1) 0%, rgba(190,34,34,1) 95%);
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
    }

    .start-button:hover {
      transform: scale(1.1);
    }

    .main-canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: -1;
    }

    @keyframes circleExpand {
      0% {
        width: 0;
        height: 0;
        opacity: 0;
      }
      50% {
        opacity: 1;
      }
      75% {
        width: 200px;
        height: 200px;
      }
      100% {
        width: 150px;
        height: 150px;
      }
    }

    @keyframes buttonExpand {
      0% {
        transform: scale(0);
      }
      100% {
        transform: scale(1);
      }
    }

    @keyframes appear {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="circle-container">
    <button id="animatedButton" class="start-button hidden-button"></button>
  </div>
  <!-- <canvas id="main-canvas" class="main-canvas"></canvas> -->
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const container = document.querySelector(".circle-container");
      const circle = document.createElement("div");

      // Create a circle
      circle.classList.add("circle");
      circle.style.pointerEvents = "none";

      container.appendChild(circle);

      // After the circle expands, show the button
      setTimeout(() => {
        // center circle inner contents
        circle.style.display = "flex";
        circle.style.justifyContent = "center";
        circle.style.alignItems = "center";
        circle.style.textAlign = "center";

        var tag = document.createElement("p");
        var text = document.createTextNode("ENTRER");
        tag.appendChild(text);
        tag.style.opacity = 0;
        tag.style.animation = "appear 1s ease-out forwards";

        circle.appendChild(tag);

        const button = document.getElementById("animatedButton");
        button.classList.remove("hidden-button");
        button.classList.add("shown-button");

        button.addEventListener("onAnimationEnd", function() {
          button.classList.remove("shown-button");
        });
      }, 1500); // Match the animation duration
    });

    if (!window.WebGLRenderingContext) {
      alert('Your browser does not support WebGL');
    }
    // const canvasElement = document.getElementById("main-canvas");
    // canvasElement.width = window.innerWidth;
    // canvasElement.height = window.innerHeight;

    // Create the scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    // Set up the camera
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(5, 2, 0);

    // Create the renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Add orbit controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    // Add light (RandomizedLight equivalent)
    const light = new THREE.PointLight(0xadd8e6, 1, 100);
    light.position.set(-5, 5, 2);
    scene.add(light);

    // Add a light source
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 5, 5).normalize();
    scene.add(dirLight);

    // Create a rounded box geometry (RoundedBox equivalent)
    const cubeRadius = 1.5
    const roundedBoxGeometry = new THREE.RoundedBoxGeometry(cubeRadius, cubeRadius, cubeRadius, 10, 0.05);  // width, height, depth, segments, radius of corner curvature
    const roundedBoxMaterial = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,            // Cube color
      roughness: 0,               // Smoothness of the surface
      metalness: 0.0,             // Non-metallic surface
      transmission: 1.0,          // Fully transparent like glass
      opacity: 0.5,               // Semi-transparent
      transparent: true,          // Allow transparency
      ior: 1.5,                   // Index of refraction (for glass-like effect)
      thickness: 0.2,             // Simulate glass thickness
    });

    const roundedBox = new THREE.Mesh(roundedBoxGeometry, roundedBoxMaterial);
    roundedBox.castShadow = true;
    scene.add(roundedBox);

    // Load a 3D model
    const glbLink = "https://files.catbox.moe/hatd9t.glb";
    const loader = new THREE.GLTFLoader();

    let mixer = undefined

    loader.load(glbLink, function(gltf) {
      const model = gltf.scene;
      const scale = 0.02
      model.scale.set(scale, scale, scale);
      model.position.set(0, 0.5, 0);

      // Create an AnimationMixer, and get the list of AnimationClip instances
      mixer = new THREE.AnimationMixer( model );

      // Play a specific animation
      const action = mixer.clipAction( gltf.animations[0], model );
      action.play();

      // Play all animations
      gltf.animations.forEach( function ( clip ) {
        mixer.clipAction( clip ).play();
      } );
      
      roundedBox.add(model);
    });

    // Environment map (HDR texture)
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    new THREE.RGBELoader()
      .setPath('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/')
      .load('dancing_hall_1k.hdr', function (texture) {
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
        scene.environment = envMap;
        texture.dispose();
        pmremGenerator.dispose();
      });

    // Accumulative Shadows simulation (light blue shadow)
    const shadowPlaneGeometry = new THREE.PlaneGeometry(10, 10);
    const shadowPlaneMaterial = new THREE.ShadowMaterial({ color: 0xadd8e6, opacity: 0.75 });
    const shadowPlane = new THREE.Mesh(shadowPlaneGeometry, shadowPlaneMaterial);
    shadowPlane.rotation.x = -Math.PI / 2;
    shadowPlane.position.y = -1;
    shadowPlane.receiveShadow = true;
    scene.add(shadowPlane);

    const clock = new THREE.Clock();

    // Render loop
    function animate() {
      requestAnimationFrame(animate);

      // Update controls
      controls.update();

      // Update animation
      mixer?.update( clock.getDelta() );

      // Rotate the box
      roundedBox.rotation.y += 0.005;
      roundedBox.position.y = Math.sin(clock.getElapsedTime() * 2) * 0.1;

      // Render the scene
      renderer.render(scene, camera);
    }

    animate();

    // Handle window resizing
    window.addEventListener('resize', () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });
  </script>
</body>
</html>
